# Лабораторная работа 1

## Теоретические сведения.
Размытие по Гауссу является усредняющем фильтром. Широко используется для уменьшения шума изображения и уменьшения детализации. Выполняется путём свёртки изображения с ядром фильтра.
Ядро фильтра – одномерная(n) или двумерная(n*n) матрица коэффициенты которой рассчитаны по формуле. 

Для одномерной:
![Формула 1](https://wikimedia.org/api/rest_v1/media/math/render/svg/dd16b16869269dba008d19c0969515a1d50b3ae2)

<!-- ![asd](https://latex.codecogs.com/gif.latex?G(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{x^{2}}{2\sigma^{2}}}) -->

Для двумерной:
![Формула 2](https://wikimedia.org/api/rest_v1/media/math/render/svg/6717136818f2166eba2db0cfc915d732add9c64f)

Нормализующий множитель при свёртке – сумма всех коэффициентов ядра.

Размытие с одномерным ядром выполняйся в два прохода, сначала свёртка с ядром расположенным вертикально, а затем результат первой обработки и ядром расположенным горизонтально.  

## Описание разработанной системы
Фильтр реализуется 3 способами:
- Реализованный вариант из библиотеки OpenCV
- В виде функции на языке Python 
- В виде функции компилируемой функции с использование компилятора Namba 

Все реализованные функции имеют приблизительно одинаковую структуру с незначительными отличиями в зависимости от способа в обработки.

Функция генерации ядра свёртки:
```python
kernelRadius = int((kernel_size - 1) / 2)   #вычисление радиуса фильтра по его размеру 
karnel = np.zeros(kernel_size)              
karnel_sum = 0                              #сумма коэффициентов фильтра 
for i in prange(kernel_size): 
    x = np.exp(-((i - kernelRadius)**2)/(2*sigma**2)) / np.sqrt(2*np.pi*sigma**2)#Вычисление коэффициента
    karnel[i] = x                           
    karnel_sum += x
for i in prange(kernel_size):
    karnel[i] = karnel[i] / karnel_sum      #нормирование ядра свёртки
return karnel
```
Функции свёртки:
```python
for channel_i in prange(channel):                           #каналы 
        for width_i in range(width):                        #пиксели по ширине 
            for height_i in range(height):                  #пиксели по высоте 
                sum_pix = 0                                 #сумма свёртки
                for i in range(kernel_size):
                    for j in range(kernel_size):
                        h = height_i - kernelRadius + i     #текущий пиксель в свёртке
                        w = width_i - kernelRadius + j      #
                        sum_pix += img[abs(h) if h < height else 2*height - h - 1][abs(w) if w < width else 2*width - w - 1][channel_i] * karnel[i][j] #умножение ядра на пиксель + проверка границ
                img[height_i][width_i][channel_i] = sum_pix #присвоение значения пикселю
```

Для GUI используется графическая библиотека PyQt5. 
GUI позволяет выбрать способ обработки и размер ядра фильтра. По нажатию кнопки 'Original' выводится исходное изображение, по нажитою кнопки 'Processed' происходит обработки изображения и его вывод на экран. В статус бар выводиться обработки изображения с заданными параметрами.

![Изображение GUI](/screen/6.png)

## Результаты работы и тестирования системы 
Результат работы всех 3 алгоритмом практически идентичен.

Оброботка фильтром с ядром 11х11:
![Зависимость 1](/img/4.png)
![Зависимость 2](/screen/5.png)

В зависимости от размере ядра фильтра пропорционально меняется и время обработки изображения.
![Зависимость 1](/screen/1.png)
![Зависимость 2](/screen/2.png)

Также время работы зависит и от размеров исходного изображения.
![Зависимость 3](/screen/3.png)
![Зависимость 4](/screen/4.png)

## Выводы по работе
В лабораторной работе был реализован один из простых методов обработки изображения, усреднявший фильтр Гаусса. Было рассмотрено несколько способов реализации, самым быстрым и эффективным был способ, использующий функции библиотеки OpenCV которая показывает практически константное время работы для любых входных данных. Немного более медленным был способ, реализованный на языке Python с использованием компилятора Namba, причём алгоритм, использующий двумерное ядро был в разы медленнее алгоритма с одномерным ядром. Реализация алгоритма исключительно на Python баз какой-либо обработки оказалось чрезвычайно медленной и практически не пригодной для применения, показывая огромные время обработки изображения.   

## Источники 
- https://habr.com/ru/post/484136/
- https://docs.opencv.org
- https://numba.pydata.org
- https://en.wikipedia.org/wiki/Gaussian_blur


